# 第11章：动态网络架构

在边缘设备部署深度学习模型时，一个关键挑战是如何在不同的资源约束和精度要求下灵活调整模型的计算量。动态网络架构提供了一种优雅的解决方案：通过在运行时动态调整网络结构，实现计算资源与任务需求的最优匹配。本章将深入探讨四种主要的动态网络技术：Slimmable Neural Networks、弹性宽度网络、早退机制和Token剪枝，这些技术为边缘AI提供了前所未有的灵活性。

## 11.1 Slimmable Neural Networks原理

### 11.1.1 动态宽度网络的基本概念

Slimmable Neural Networks (S-Net) 的核心思想是训练一个可以在不同宽度配置下工作的单一网络。与传统的固定架构不同，S-Net允许在推理时动态选择网络宽度，从而在单一模型中实现多种精度-效率权衡。

**数学建模与通道选择**

设原始网络在第l层有C_l个通道，S-Net定义了一组宽度比例因子 α = {α_1, α_2, ..., α_k}，其中 0 < α_i ≤ 1。在推理时，第l层使用的通道数为：

C_l^(α_i) = ⌊α_i · C_l⌋

这种设计使得同一个网络可以在不同的计算预算下运行。例如，当 α = {0.25, 0.5, 0.75, 1.0} 时，网络可以在25%、50%、75%和100%的宽度下工作。

**实例分析：ResNet-50的Slimmable变体**

考虑ResNet-50的第一个残差块，原始配置为：
- Conv1: 64 → 64, 1×1
- Conv2: 64 → 64, 3×3
- Conv3: 64 → 256, 1×1

在α = 0.5的配置下：
- Conv1: 32 → 32, 1×1
- Conv2: 32 → 32, 3×3
- Conv3: 32 → 128, 1×1

计算量从原始的 3.7M FLOPs 降至约 0.93M FLOPs，实现了75%的计算节省。

**通道选择的有序性原则**

一个关键的设计原则是通道选择的有序性。对于任意两个宽度配置 α_i < α_j，选择的通道集合满足：

Channels(α_i) ⊆ Channels(α_j)

这意味着较窄的网络使用的通道是较宽网络通道的子集。这种设计确保了：
1. 参数共享最大化：窄网络完全复用宽网络的参数
2. 训练稳定性：避免了不同宽度间的参数冲突
3. 硬件友好：连续的内存访问模式

**数学证明：有序性原则的重要性**

假设违反有序性原则，即存在通道c满足 c ∈ Channels(α_i) 但 c ∉ Channels(α_j)，其中 α_i < α_j。这会导致：

1. **梯度冲突**：设参数θ_c对应通道c，在训练时：
   ∇θ_c L = P(α_i) · ∇θ_c L^(α_i) + (1-P(α_i)) · 0
   
   其中P(α_i)是选择宽度α_i的概率。这种不一致的梯度更新会导致训练不稳定。

2. **特征依赖破坏**：深层网络依赖浅层特征，不连续的通道选择破坏了特征传递的一致性。

**计算复杂度分析**

对于标准卷积层，宽度为α的网络的计算复杂度为：

FLOPs(α) = α² · FLOPs(1.0)

这是因为输入和输出通道数都按α缩放。具体推导：

设卷积核大小为K×K，输入通道C_in，输出通道C_out，特征图大小H×W，则：
- 完整网络：FLOPs(1.0) = K² · C_in · C_out · H · W
- 宽度α网络：FLOPs(α) = K² · (α·C_in) · (α·C_out) · H · W = α² · FLOPs(1.0)

对于深度可分离卷积：

FLOPs_dw(α) = α · FLOPs_dw(1.0)
FLOPs_pw(α) = α² · FLOPs_pw(1.0)

**实例计算：MobileNetV2中的深度可分离卷积**

考虑输入224×224×32的深度可分离卷积块：
- Depthwise: 3×3×32, FLOPs = 3²×32×224² = 14.5M
- Pointwise: 1×1×32×96, FLOPs = 32×96×224² = 154.1M

在α = 0.5时：
- Depthwise: FLOPs(0.5) = 0.5×14.5M = 7.25M
- Pointwise: FLOPs(0.5) = 0.25×154.1M = 38.5M
- 总计算量降低至 (7.25+38.5)/(14.5+154.1) ≈ 27%

内存占用则呈线性关系：

Memory(α) = α · Memory(1.0) + Memory_fixed

其中Memory_fixed包括批归一化参数等固定开销。

**内存占用的详细分析**

考虑每层的内存需求：
1. **权重内存**：W_mem(α) = α² · W_mem(1.0)
2. **激活内存**：A_mem(α) = α · A_mem(1.0)
3. **固定内存**：包括BN参数 (2×C_l)、偏置等

总内存公式：
Memory_total(α) = Σ_l [α²·W_l + α·A_l + 2·C_l]

对于ResNet-50，完整模型约25.5M参数，α=0.5时参数量降至约6.4M，但考虑BN参数后实际为6.5M。

### 11.1.2 可切换批归一化（Switchable BN）

S-Net面临的一个关键挑战是批归一化（BN）层的处理。不同宽度的网络具有不同的特征分布，使用相同的BN参数会导致性能严重下降。Switchable BN通过为每个宽度配置维护独立的BN参数解决了这个问题。

**理论基础：为什么需要Switchable BN**

考虑第l层在不同宽度下的激活分布。设完整网络的激活为 X^(1.0) ∈ R^{B×C_l×H×W}，宽度α下的激活为 X^(α) ∈ R^{B×αC_l×H×W}。由于：

1. 通道选择改变了特征的表示能力
2. 前面层的宽度变化产生累积效应
3. 不同宽度下的优化路径不同

导致 E[X^(α)] ≠ E[X^(1.0)] 且 Var[X^(α)] ≠ Var[X^(1.0)]。

**实验验证：特征分布差异**

在ImageNet预训练的ResNet-50上测量不同宽度的激活统计量：
- Layer 2.1: μ(1.0)=0.42, σ(1.0)=1.23 vs μ(0.5)=0.31, σ(0.5)=0.87
- Layer 3.4: μ(1.0)=0.18, σ(1.0)=0.95 vs μ(0.5)=0.25, σ(0.5)=1.42

这种分布偏移在深层更加明显，验证了Switchable BN的必要性。

**Switchable BN的数学表达**

对于宽度配置α_i，BN层的计算为：

y^(α_i) = γ^(α_i) · (x - μ^(α_i))/√(σ^(α_i)² + ε) + β^(α_i)

其中，μ^(α_i)和σ^(α_i)是宽度α_i对应的运行均值和方差，γ^(α_i)和β^(α_i)是对应的缩放和偏移参数。

在训练时，每个宽度配置的BN统计量独立更新：

μ^(α_i) ← (1 - m) · μ^(α_i) + m · μ_batch^(α_i)
σ^(α_i)² ← (1 - m) · σ^(α_i)² + m · σ_batch^(α_i)²

其中m是动量参数，μ_batch和σ_batch是当前批次的统计量。

**收敛性分析**

设真实均值为μ*，批次均值的方差为σ²_batch/B（B为批大小），则运行均值的收敛速度为：

E[(μ^(t) - μ*)²] = (1-m)^(2t) · E[(μ^(0) - μ*)²] + m²σ²_batch/(B(1-(1-m)²))

当t→∞时，稳态误差为 m²σ²_batch/(B(2m-m²))。选择m=0.1时，需要约50个迭代达到95%收敛。

**参数存储优化**

Switchable BN的额外参数开销为：

Params_SBN = |α| × (2 × Σ_l αC_l)

对于ResNet-50和4个宽度配置，额外参数约占总参数的0.5%。具体计算：
- ResNet-50总参数：25.5M
- BN参数（4宽度）：0.13M
- 相对开销：0.51%

为进一步减少开销，可以采用：

1. **参数共享策略**：相近宽度共享部分BN参数
   γ^(0.75) = λγ^(1.0) + (1-λ)γ^(0.5)
   
   其中λ = (0.75-0.5)/(1.0-0.5) = 0.5，线性插值确保平滑过渡。

2. **低秩分解**：将BN参数分解为共享基础和宽度特定偏移
   γ^(α_i) = γ_base + Δγ^(α_i)
   
   其中Δγ^(α_i) = U_i · V，U_i ∈ R^{C_l×r}，V ∈ R^r，r << C_l

3. **条件BN**：使用小型网络生成BN参数
   (γ^(α_i), β^(α_i)) = g_θ(α_i)
   
   生成器g_θ通常是2-3层MLP，参数量约1K-5K。

**训练稳定性考虑**

Switchable BN训练中的关键问题：

1. **统计量初始化**：新宽度的BN统计量可从最近宽度插值
   μ^(α_new) = (1-w)μ^(α_lower) + w·μ^(α_upper)
   
   其中w = (α_new - α_lower)/(α_upper - α_lower)

2. **动量调度**：早期使用较大动量快速收敛统计量
   m(t) = m_init + (m_final - m_init) × (1 - e^(-t/τ))
   
   典型设置：m_init=0.5, m_final=0.1, τ=10 epochs

3. **梯度缩放**：平衡不同宽度的梯度贡献
   ∇_θ L^(α_i) ← ∇_θ L^(α_i) / √(α_i)
   
   这补偿了窄网络较小的激活值导致的梯度减小。

**实际实现细节**

在PyTorch中，Switchable BN可通过维护多组running_mean和running_var实现：

```
self.bn_dict = nn.ModuleDict({
    str(alpha): nn.BatchNorm2d(int(alpha * channels))
    for alpha in alphas
})
```

推理时根据当前宽度选择对应的BN层，训练时需要确保只更新当前宽度的统计量。

### 11.1.3 训练策略：三明治规则与渐进收缩

**三明治规则（Sandwich Rule）**

S-Net的训练采用"三明治规则"：在每个训练步骤中，同时训练最小宽度、最大宽度和若干中间宽度。这种策略确保了网络在极端情况下的性能，同时通过中间宽度的训练保证了平滑的性能变化。

训练损失函数为：

L_sandwich = L(α_min) + L(α_max) + Σ_(i∈S) L(α_i)

其中S是随机采样的中间宽度集合。

**三明治规则的理论分析**

三明治规则的有效性可以从优化角度理解。考虑参数θ的梯度：

∇_θ L_sandwich = ∇_θ L(α_min) + ∇_θ L(α_max) + Σ_(i∈S) ∇_θ L(α_i)

这确保了：
1. **边界性能保证**：最小和最大宽度的显式优化避免了性能退化
2. **梯度覆盖**：不同宽度的梯度方向互补，提高参数利用率
3. **插值平滑性**：中间宽度的训练使性能曲线更平滑

**梯度冲突分析**

不同宽度的梯度可能存在冲突。定义梯度相似度：

cos(∇_θ L^(α_i), ∇_θ L^(α_j)) = (∇_θ L^(α_i) · ∇_θ L^(α_j))/(||∇_θ L^(α_i)|| · ||∇_θ L^(α_j)||)

实验表明：
- 相邻宽度（如0.5和0.75）：cos值通常 > 0.7
- 极端宽度（如0.25和1.0）：cos值可能 < 0.3

这说明极端宽度间确实存在优化冲突，需要权衡。

**采样策略优化**

中间宽度的采样策略影响训练效率：

1. **均匀采样**：P(α_i) = 1/|α|
   简单但可能浪费计算在已收敛的宽度上

2. **重要性采样**：P(α_i) ∝ exp(-|Acc(α_i) - Acc_target|/T)
   集中训练接近目标精度的宽度，T控制集中程度

3. **课程采样**：随训练进程调整采样分布
   P(α_i|t) = softmax(w(t) · [α_1, ..., α_k])
   其中w(t) = 1 + (k-1)·exp(-t/τ)，从偏好大宽度逐渐过渡到均匀

**实例：ImageNet上的采样策略对比**

在ResNet-50的训练中（300 epochs）：
- 均匀采样：Top-1 Acc差异 < 0.5% across widths
- 重要性采样：训练时间减少15%，精度相当
- 课程采样：收敛速度提升20%，最终精度提升0.3%

**渐进收缩训练（Progressive Shrinking）**

另一种有效的训练策略是渐进收缩：首先训练完整宽度的网络，然后逐步引入更窄的宽度配置。这种方法利用了知识蒸馏的思想，让窄网络从宽网络学习。

训练过程分为多个阶段：
- 阶段1：仅训练α = 1.0（100 epochs）
- 阶段2：联合训练α = {0.75, 1.0}（50 epochs）
- 阶段3：联合训练α = {0.5, 0.75, 1.0}（50 epochs）
- 阶段4：联合训练所有宽度配置（100 epochs）

每个阶段的损失函数包含蒸馏项：

L_stage = Σ_i L_CE(y^(α_i), y_true) + λ Σ_i KL(y^(α_i) || y^(α_max))

其中KL表示KL散度，用于让窄网络模仿宽网络的输出分布。

**知识传递的数学分析**

蒸馏的有效性可以通过信息论解释。定义宽网络包含的"知识"为其输出分布的熵：

H(y^(α_max)) = -Σ_c p_c^(α_max) log p_c^(α_max)

通过最小化KL散度，窄网络学习的信息量为：

I_transfer = H(y^(α_i)) - KL(y^(α_i) || y^(α_max))

理想情况下，I_transfer ≈ H(y^(α_max))，表示知识完全传递。

**蒸馏温度调节**

在知识蒸馏中，温度参数T控制软标签的平滑程度：

p_i = exp(z_i/T) / Σ_j exp(z_j/T)

对于不同宽度比例，最优温度不同：
- 窄网络（α < 0.5）：使用较高温度T ∈ [5, 10]
- 中等网络（0.5 ≤ α < 0.75）：T ∈ [3, 5]
- 宽网络（α ≥ 0.75）：T ∈ [1, 3]

**温度选择的理论依据**

最优温度与网络容量比相关：

T_opt ≈ T_0 · (C_teacher/C_student)^β

其中T_0是基准温度，β ≈ 0.5。对于α=0.25的学生网络：
T_opt ≈ 3 × (1.0/0.25)^0.5 ≈ 6

这与经验观察一致。

**训练技巧与超参数设置**

1. **学习率调度**：不同宽度使用独立学习率
   lr^(α_i) = lr_base × √(α_i)
   
   理由：窄网络的有效参数数较少，需要更小的学习率避免过拟合

2. **批大小调整**：保持每个宽度的有效批大小一致
   batch_size^(α_i) = batch_size_base / |α_active|
   
   例如：base=256, 4个宽度同时训练时每个宽度batch_size=64

3. **正则化强度**：窄网络需要更强的正则化
   weight_decay^(α_i) = wd_base / α_i
   
   dropout_rate^(α_i) = drop_base + (1-α_i) × 0.1

4. **训练周期分配**：根据宽度复杂度分配训练时间
   epochs^(α_i) = epochs_base × (2 - α_i)
   
   窄网络需要更多训练来补偿容量不足

**收敛性保证**

在适当条件下，三明治规则训练可以保证收敛。设L_i = L(α_i)为凸函数，学习率η满足：

η < 2/(Σ_i L_i^max)

其中L_i^max是L_i的Lipschitz常数。则训练损失单调递减：

L^(t+1) ≤ L^(t) - η/2 · ||∇L^(t)||²

### 11.1.4 宽度选择的优化准则

在推理时，如何选择合适的网络宽度是一个重要问题。常见的准则包括：

**1. 精度约束下的效率最大化**

给定精度阈值τ，选择满足精度要求的最小宽度：

α* = min{α_i : Acc(α_i) ≥ τ}

实际部署中，考虑精度的统计特性：

α* = min{α_i : P(Acc(α_i) ≥ τ) ≥ 1-δ}

其中δ是失败概率容忍度。

**2. 延迟约束下的精度最大化**

给定延迟预算T，选择在预算内的最大宽度：

α* = max{α_i : Latency(α_i) ≤ T}

考虑延迟的变异性：

α* = max{α_i : P95(Latency(α_i)) ≤ T}

其中P95表示95百分位延迟。

**3. 动态宽度选择**

根据输入的复杂度动态选择宽度。定义复杂度评分函数f(x)，然后：

α(x) = α_min + (α_max - α_min) · σ(f(x))

其中σ是sigmoid函数，将复杂度映射到宽度选择。

**复杂度评估方法**

输入复杂度f(x)的计算方法：

1. **基于熵的复杂度**：
   f_entropy(x) = -Σ_i p_i log p_i
   其中p_i是输入x的特征直方图

2. **基于梯度的复杂度**：
   f_gradient(x) = ||∇_x L(x)||_2
   使用小型代理网络估计

3. **基于频谱的复杂度**：
   f_spectrum(x) = Σ_k λ_k / λ_1
   其中λ_k是x的奇异值

**4. 多目标优化准则**

实际应用中需要平衡多个目标：

α* = argmin_α [w_1·Latency(α) + w_2·Energy(α) - w_3·Acc(α)]

使用Pareto优化找到非支配解集：

Pareto(α) = {α_i | ¬∃α_j : α_j ≺ α_i}

其中α_j ≺ α_i表示α_j在所有目标上都不差于α_i，且至少在一个目标上更优。

**5. 强化学习宽度选择**

训练一个策略网络π(α|x)选择宽度：

π_θ(α|x) = softmax(f_θ(x))

奖励函数结合精度和效率：

R(x, α) = Acc(x, α) - β·Cost(x, α)

使用PPO或A3C算法优化策略。

**6. 贝叶斯宽度优化**

建模宽度选择的不确定性：

P(α|x, D) ∝ P(y|x, α)P(α|D)

其中D是历史数据，使用高斯过程或贝叶斯神经网络建模。

**实际部署考虑**

1. **预计算查找表**：离线评估不同场景的最优宽度
   LUT[scenario] → α_optimal

2. **自适应阈值调整**：根据系统负载动态调整
   τ(t) = τ_base × (1 + k·load(t))

3. **分层决策**：先用轻量级分类器快速决策
   if classifier(x) == "simple":
       return α_min
   else:
       return detailed_selection(x)

## 11.2 弹性宽度网络设计

### 11.2.1 通道重要性评估方法

弹性宽度网络的核心在于识别哪些通道对模型性能贡献最大。这不仅影响剪枝决策，还决定了在不同宽度配置下应该保留哪些通道。主要的评估方法包括：

**1. 基于梯度的重要性评分**

Taylor展开提供了一种理论基础扎实的重要性评估方法。对于通道c，其重要性可以通过损失函数对该通道输出的一阶导数近似：

I_c = |∂L/∂z_c| · |z_c|

其中z_c是通道c的激活值。这个公式结合了梯度幅度和激活幅度，反映了该通道对损失函数的影响。

**Taylor展开的高阶近似**

考虑二阶Taylor展开获得更精确的重要性估计：

ΔL_c = (∂L/∂z_c)·Δz_c + (1/2)·(∂²L/∂z_c²)·(Δz_c)²

当移除通道c时，Δz_c = -z_c，因此：

I_c = |∂L/∂z_c·z_c| + (1/2)|∂²L/∂z_c²·z_c²|

第二项通常通过有限差分近似：

∂²L/∂z_c² ≈ (∂L/∂z_c|_{z_c+ε} - ∂L/∂z_c|_{z_c-ε})/(2ε)

**2. 基于Fisher信息的重要性**

Fisher信息矩阵提供了参数重要性的二阶信息。对于通道c的参数θ_c，其重要性为：

I_c = θ_c^T F_c θ_c

其中F_c是对应于通道c参数的Fisher信息矩阵块：

F_c = E[∇_θ_c log p(y|x,θ) · ∇_θ_c log p(y|x,θ)^T]

实践中，通常使用对角近似：

I_c ≈ Σ_i (θ_c,i)² · E[(∂log p/∂θ_c,i)²]

**经验Fisher信息矩阵（EFM）**

使用训练数据的经验估计：

F̂_c = (1/N) Σ_n ∇_θ_c log p(y_n|x_n,θ) · ∇_θ_c log p(y_n|x_n,θ)^T

为提高计算效率，使用Kronecker分解：

F̂_c ≈ F̂_input ⊗ F̂_output

其中F̂_input和F̂_output分别是输入和输出的Fisher信息。

**3. 基于激活统计的重要性**

一种简单但有效的方法是基于激活的统计特性：

I_c = E[|z_c|] / (Var[z_c] + ε)

这个指标倾向于选择激活值大且稳定的通道。

**增强的统计指标**

1. **峰度调整的重要性**：
   I_c = E[|z_c|] × (1 + λ·Kurt[z_c])
   其中Kurt[z_c]是峰度，捕获激活分布的尾部特性

2. **互信息重要性**：
   I_c = MI(z_c; y) = Σ_y p(y) KL(p(z_c|y) || p(z_c))
   衡量通道激活与输出标签的相关性

3. **条件熵重要性**：
   I_c = H(y) - H(y|z_c)
   表示通道c减少的输出不确定性

**4. 基于注意力的重要性**

利用自注意力机制评估通道间的相互依赖：

A = softmax(Q·K^T/√d)
I_c = Σ_i A_{ic} + Σ_j A_{cj}

其中A_{ic}表示其他通道对通道c的注意力权重。

**5. 学习式重要性预测器**

训练专门的网络预测通道重要性：

I = g_φ(Z)

其中Z是层的激活，g_φ是轻量级预测网络。训练目标：

L_pred = ||I - I_true||² + λ·||I||_1

其中I_true通过暴力搜索或敏感度分析获得。

### 11.2.2 宽度配置的搜索空间

设计有效的宽度配置搜索空间需要平衡灵活性和训练复杂度。常见的搜索空间设计包括：

**1. 均匀宽度配置**

所有层使用相同的宽度比例：

W = {α · C_l | α ∈ A, l = 1,...,L}

其中A = {0.25, 0.5, 0.75, 1.0}是预定义的宽度比例集合。

**2. 层级独立配置**

每层可以独立选择宽度：

W = {(α_1·C_1, α_2·C_2, ..., α_L·C_L) | α_l ∈ A}

搜索空间大小为|A|^L，需要使用搜索算法如进化算法或强化学习。

**3. 分组配置**

将网络分为若干组（如按阶段或按残差块），组内层使用相同宽度：

W = {(α_g1·C_g1, α_g2·C_g2, ..., α_gK·C_gK) | α_gi ∈ A}

这种方法在搜索空间大小和灵活性之间取得平衡。

### 11.2.3 多宽度联合训练技术

**1. 知识蒸馏增强训练**

在多宽度训练中，可以利用宽网络指导窄网络的学习：

L_distill = Σ_i CE(y_i, y_true) + λ_KD Σ_i<j KL(y_i || y_j)

其中i < j表示宽度α_i < α_j，宽网络的输出作为窄网络的软标签。

**2. 渐进式宽度采样**

训练初期更多采样宽网络，后期增加窄网络的采样概率：

P(α_i | epoch) = softmax(β(epoch) · score(α_i))

其中β(epoch)是随训练进程增加的温度参数，score(α_i)反映宽度α_i的优先级。

**3. 对抗训练策略**

引入对抗性扰动提高不同宽度网络的鲁棒性：

L_adv = max_||δ||≤ε Σ_i L(f(x+δ; α_i), y)

这确保了窄网络在面对扰动时仍能保持性能。

### 11.2.4 推理时宽度选择策略

**1. 基于置信度的动态选择**

使用小宽度网络的预测置信度决定是否需要更大的网络：

```
α = α_min
for i in range(len(A)):
    conf = max(softmax(f(x; α)))
    if conf > threshold:
        break
    α = A[i+1]
```

**2. 级联式推理**

逐步增加网络宽度，直到预测稳定：

convergence = |f(x; α_i) - f(x; α_{i-1})| < ε

**3. 基于资源的自适应选择**

根据当前系统资源动态调整：

α* = max{α_i : Memory(α_i) ≤ M_available ∧ Power(α_i) ≤ P_budget}

其中Memory和Power是资源消耗的预测函数。

## 11.3 早退机制（Early Exit）

### 11.3.1 早退网络的数学建模

早退网络在模型的不同深度设置多个出口，允许简单样本在浅层就得到预测结果，从而大幅减少平均计算量。这种机制特别适合边缘设备上的实时推理场景。

**基本架构**

设神经网络有L层，在第l_1, l_2, ..., l_K层设置K个早退出口，其中l_K = L。每个出口包含一个分类器g_i，网络的前向传播可以表示为：

h_0 = x
h_l = f_l(h_{l-1}), l = 1, ..., L
y_i = g_i(h_{l_i}), i = 1, ..., K

**早退决策函数**

关键在于设计合适的退出决策函数。常见的方法基于预测的置信度：

exit_i = 1{max(softmax(y_i)) > τ_i}

其中τ_i是第i个出口的置信度阈值。

**计算节省分析**

假设样本在第i个出口退出的概率为p_i，平均计算成本为：

C_avg = Σ_{i=1}^K p_i · C_i

其中C_i是执行到第i个出口的计算成本。相对于完整网络的加速比为：

Speedup = C_L / C_avg = C_L / (Σ_{i=1}^K p_i · C_i)

### 11.3.2 置信度阈值设计

**1. 固定阈值策略**

最简单的方法是为所有出口设置相同的阈值：

τ_i = τ, ∀i

这种方法简单但可能不够优化，因为不同深度的网络置信度分布差异较大。

**2. 自适应阈值**

根据每个出口的置信度分布设置阈值：

τ_i = μ_i + k · σ_i

其中μ_i和σ_i是第i个出口在验证集上的置信度均值和标准差，k是控制参数。

**3. 基于成本的阈值优化**

考虑计算成本和精度的权衡，通过优化问题确定阈值：

min_{τ_1,...,τ_K} Σ_{i=1}^K p_i(τ_i) · C_i
s.t. Acc(τ_1,...,τ_K) ≥ Acc_target

可以使用动态规划或贪婪算法求解。

**4. 熵基准的退出策略**

使用预测分布的熵作为不确定性度量：

H(y_i) = -Σ_c p_c log p_c

exit_i = 1{H(y_i) < η_i}

低熵表示高置信度，适合退出。

### 11.3.3 多出口网络训练方法

**1. 联合训练损失**

所有出口同时训练，总损失为各出口损失的加权和：

L_total = Σ_{i=1}^K w_i · L_i(y_i, y_true)

权重w_i通常随深度递增，确保深层网络的性能。

**2. 知识蒸馏训练**

使用最后一个出口（完整网络）的预测作为前面出口的软标签：

L_i = (1-α) · CE(y_i, y_true) + α · KL(y_i || y_K)

这帮助浅层出口学习深层网络的知识。

**3. 梯度平衡技术**

不同出口的梯度量级可能差异很大，使用梯度归一化：

∇θ_l ← ∇θ_l / ||∇θ_l||_2

或者使用GradNorm等自适应方法平衡多任务学习。

**4. 逐层增量训练**

先训练完整网络，然后逐步添加早退出口：

- Step 1: 训练基础网络f_1, ..., f_L和g_K
- Step 2: 固定网络，训练g_{K-1}
- Step 3: 联合微调所有参数
- 重复直到所有出口训练完成

### 11.3.4 延迟-精度权衡分析

**1. Pareto前沿分析**

通过调整阈值τ = (τ_1, ..., τ_K)，可以得到延迟-精度的Pareto前沿：

Pareto = {(Latency(τ), Accuracy(τ)) | τ ∈ T}

其中T是阈值空间。最优配置在Pareto前沿上。

**2. 预算约束优化**

给定延迟预算B，最大化精度：

max_τ Accuracy(τ)
s.t. Latency(τ) ≤ B

使用拉格朗日方法：

L(τ, λ) = Accuracy(τ) - λ(Latency(τ) - B)

**3. 动态预算分配**

根据系统负载动态调整延迟预算：

B(t) = B_base · (1 + β · (Load_target - Load(t)))

高负载时降低预算，加速推理；低负载时提高预算，改善精度。

**4. 样本级别的自适应**

不同样本的复杂度不同，可以基于输入特征预测合适的退出点：

l_exit = f_policy(x)

其中f_policy是一个轻量级网络，预测每个样本的最优退出层。

## 11.4 Token剪枝与合并（ToMe）

### 11.4.1 Token重要性评分机制

在Transformer架构中，并非所有token都对最终预测贡献相同。Token剪枝通过识别和移除不重要的token来减少计算量，这在处理长序列时尤其重要。

**1. 基于注意力的重要性评分**

利用注意力权重评估token重要性：

I_i = Σ_{h=1}^H Σ_{j=1}^N A_{ij}^{(h)}

其中A_{ij}^{(h)}是第h个注意力头中token j对token i的注意力权重。高分表示该token被其他token频繁关注。

**2. 基于梯度的重要性**

通过计算损失对token嵌入的梯度：

I_i = ||∂L/∂x_i||_2

这反映了移除该token对模型输出的影响。

**3. 学习式重要性预测**

训练一个轻量级网络预测token重要性：

s = f_score(X) ∈ R^N

其中X ∈ R^{N×d}是token序列，s_i是第i个token的重要性分数。

**4. 基于相似度的冗余检测**

计算token之间的余弦相似度，识别冗余token：

R_{ij} = cos(x_i, x_j) = (x_i · x_j)/(||x_i|| · ||x_j||)

高相似度的token对可以考虑合并或剪枝。

### 11.4.2 Token合并的数学原理

Token合并（Token Merging, ToMe）通过将相似的token合并来减少序列长度，保留更多信息。

**1. 加权平均合并**

给定要合并的token集合S = {i_1, ..., i_k}，合并后的token为：

x_merged = Σ_{j∈S} w_j · x_j / Σ_{j∈S} w_j

权重w_j可以基于重要性分数或注意力权重。

**2. 基于聚类的合并**

使用K-means或层次聚类将token分组：

min_C Σ_{k=1}^K Σ_{x_i∈C_k} ||x_i - μ_k||²

其中C_k是第k个簇，μ_k是簇中心。每个簇合并为一个token。

**3. 双线性池化合并**

对于token对(x_i, x_j)，使用双线性池化：

x_merged = W(x_i ⊗ x_j) + b

其中⊗表示外积，W和b是可学习参数。

**4. 注意力引导的合并**

利用自注意力矩阵确定合并策略：

M = A^T A

其中M_{ij}表示token i和j的相关性。选择M值最大的token对进行合并。

### 11.4.3 动态Token剪枝策略

**1. 固定比例剪枝**

保留重要性最高的k个token：

X_pruned = TopK(X, I, k)

其中k = ⌊r · N⌋，r是保留比例。

**2. 自适应阈值剪枝**

基于重要性分布动态确定阈值：

τ = percentile(I, p)
X_pruned = {x_i | I_i > τ}

**3. 层级渐进剪枝**

在不同层使用不同的剪枝率：

r_l = r_min + (r_max - r_min) · (l/L)^γ

深层使用更激进的剪枝，因为特征已经更加抽象。

**4. 任务相关的动态剪枝**

根据下游任务调整剪枝策略：

- 分类任务：保留[CLS] token周围的重要token
- 生成任务：保留最近的k个token（滑动窗口）
- 问答任务：保留问题相关的token

### 11.4.4 在LLM/VLM中的应用

**1. LLM中的Token剪枝**

在大语言模型中，Token剪枝主要应用于：

- **Attention计算优化**：剪枝KV cache中的token
  
  KV_pruned = PruneTokens(KV, importance_scores)
  
- **长文本处理**：动态调整上下文窗口
  
  context_window = min(max_length, important_tokens + buffer)

**2. VLM中的跨模态Token管理**

视觉语言模型需要平衡视觉和文本token：

- **视觉Token压缩**：
  
  N_visual = f_allocate(task_type) · N_total
  
  根据任务类型分配视觉token预算。

- **动态分辨率调整**：
  
  resolution = base_res · sqrt(token_budget / base_tokens)

**3. 流式推理中的Token管理**

在实时场景中，需要在线决策token取舍：

```
buffer = PriorityQueue(capacity=max_tokens)
for new_token in stream:
    importance = compute_importance(new_token)
    if buffer.full():
        if importance > buffer.min_importance():
            buffer.pop_min()
            buffer.push(new_token, importance)
    else:
        buffer.push(new_token, importance)
```

**4. 多轮对话中的历史压缩**

保留对话历史的关键信息：

- **摘要式压缩**：定期生成历史摘要token
- **重要性衰减**：I_t = I_0 · exp(-λ·t)
- **主题聚类**：保留每个主题的代表性token

## 本章小结

动态网络架构为边缘AI推理提供了灵活且高效的解决方案。通过本章的学习，我们深入理解了四种关键技术：

1. **Slimmable Neural Networks**：通过可切换批归一化和多宽度训练，实现了单一模型适应多种资源约束的能力。三明治规则和渐进收缩训练策略确保了不同宽度下的性能。

2. **弹性宽度网络设计**：基于通道重要性评估，设计了灵活的宽度配置搜索空间。多宽度联合训练技术和动态宽度选择策略使得网络能够根据实际需求调整计算量。

3. **早退机制**：通过在网络不同深度设置多个出口，实现了样本级别的自适应计算。置信度阈值设计和多出口训练方法是确保早退网络性能的关键。

4. **Token剪枝与合并**：针对Transformer架构，通过评估token重要性并进行剪枝或合并，有效减少了序列长度和计算量。这在处理长文本和多模态输入时尤为重要。

这些技术的核心思想是**计算的自适应性**——根据输入复杂度、资源约束和精度要求动态调整网络结构。在实际部署中，这些技术可以组合使用，例如：
- 在VLM中同时使用Token剪枝和早退机制
- 结合Slimmable网络和动态Token管理优化长序列处理
- 使用弹性宽度设计增强早退网络的灵活性

关键公式回顾：
- Slimmable网络宽度：C_l^(α_i) = ⌊α_i · C_l⌋
- 早退加速比：Speedup = C_L / (Σ_{i=1}^K p_i · C_i)
- Token重要性：I_i = Σ_{h=1}^H Σ_{j=1}^N A_{ij}^{(h)}
- 合并策略：x_merged = Σ_{j∈S} w_j · x_j / Σ_{j∈S} w_j

## 练习题

### 基础题

1. **Slimmable Networks理解**
   
   解释为什么Slimmable Neural Networks需要使用Switchable BN而不能使用普通的批归一化。如果强制使用相同的BN参数会发生什么？
   
   *Hint: 考虑不同宽度网络的特征分布差异*

2. **早退机制计算**
   
   假设一个5层网络在第2、3、5层设置了早退出口，各层的计算成本为[10, 20, 30, 40, 50] FLOPs，样本在各出口的退出概率为[0.3, 0.5, 0.2]。计算平均计算成本和加速比。
   
   *Hint: 使用公式C_avg = Σ p_i · C_i*

3. **Token重要性评分**
   
   给定一个4×4的注意力矩阵A，计算每个token基于注意力的重要性分数：
   ```
   A = [[0.4, 0.3, 0.2, 0.1],
        [0.1, 0.5, 0.3, 0.1],
        [0.2, 0.2, 0.4, 0.2],
        [0.1, 0.1, 0.2, 0.6]]
   ```
   
   *Hint: 对每个token，累加所有其他token对它的注意力权重*

4. **宽度配置设计**
   
   设计一个4层网络的宽度配置方案，原始通道数为[64, 128, 256, 512]，要求支持25%、50%、75%、100%四种宽度。计算每种配置的通道数。
   
   *Hint: 使用floor函数确保通道数为整数*

### 挑战题

5. **多目标优化问题**
   
   在早退网络中，如何设计一个优化算法同时考虑：(a)平均延迟不超过原网络的50%，(b)准确率下降不超过2%，(c)最大化能效(准确率/能耗)？请给出优化问题的数学形式。
   
   *Hint: 考虑使用多目标优化或约束优化方法*

6. **Token合并策略分析**
   
   比较基于聚类的Token合并和基于注意力的Token合并在以下场景的优劣：(a)处理重复性文本，(b)处理技术文档，(c)多轮对话历史压缩。设计一个自适应策略根据输入特征选择合并方法。
   
   *Hint: 分析不同场景下token的分布特征*

7. **动态网络架构组合**
   
   设计一个结合Slimmable网络、早退机制和Token剪枝的统一框架。如何协调这三种技术避免冲突？给出训练算法伪代码。
   
   *Hint: 考虑分阶段训练或联合优化策略*

8. **理论分析题**
   
   证明在满足某些条件下，使用早退机制的期望计算成本严格小于完整网络。这些条件是什么？如何在实践中验证这些条件？
   
   *Hint: 使用概率论分析退出概率分布的约束*

<details>
<summary>答案</summary>

1. Switchable BN是必要的，因为不同宽度的网络具有不同的特征分布。使用相同BN参数会导致归一化不当，严重降低窄网络性能（可能下降20-30%）。每个宽度需要独立统计量以正确归一化特征。

2. C_avg = 0.3×(10+20) + 0.5×(10+20+30) + 0.2×(10+20+30+40+50) = 9 + 30 + 30 = 69 FLOPs
   加速比 = 150/69 ≈ 2.17

3. I = [0.8, 1.1, 1.1, 1.0]（每个token被其他token关注的总和）

4. 25%: [16, 32, 64, 128]
   50%: [32, 64, 128, 256]  
   75%: [48, 96, 192, 384]
   100%: [64, 128, 256, 512]

5. 优化问题：
   max_{τ,α} Acc(τ,α)/Energy(τ,α)
   s.t. Latency(τ,α) ≤ 0.5×Latency_base
        Acc(τ,α) ≥ 0.98×Acc_base
   可使用Pareto优化或ε-约束方法求解。

6. 聚类合并适合重复性文本（相似token多），注意力合并适合技术文档（保留关键术语）。自适应策略：计算token分布熵，低熵用聚类，高熵用注意力。

7. 训练框架：
   Phase 1: 训练Slimmable基础网络
   Phase 2: 添加早退分支，冻结主干
   Phase 3: 引入Token剪枝，联合微调
   协调关键：共享重要性评分，统一资源分配

8. 条件：∃i < K, p_i > 0 且 Σ_{j≤i} p_j > C_i/C_K
   证明：E[C] = Σp_i·C_i < Σp_i·C_K = C_K
   验证：统计验证集上的退出分布
</details>
